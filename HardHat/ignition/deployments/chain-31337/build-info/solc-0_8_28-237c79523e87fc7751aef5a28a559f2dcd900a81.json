{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-237c79523e87fc7751aef5a28a559f2dcd900a81",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Catalog.sol": "project/contracts/Catalog.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/Catalog.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.28;\r\n\r\ncontract Catalog {\r\n    enum State { Active, Expired }\r\n\r\n    struct Promo {\r\n        State state;\r\n        uint start;\r\n        uint end;\r\n        uint percent;\r\n    }\r\n\r\n    struct Product {\r\n        bytes32 code;\r\n        string description;\r\n        uint price;\r\n        bool inStock;\r\n        uint stock;\r\n    }\r\n\r\n    Product[] public products;\r\n    mapping(bytes32 => Promo) public productPromos;\r\n    mapping(bytes32 => uint) private productIndex;\r\n\r\n    address public admin;\r\n    mapping(address => bool) public authorizedManagers;\r\n\r\n    event ProductAdded(bytes32 indexed code, string description, uint price);\r\n    event StockUpdated(bytes32 indexed code, uint newStock);\r\n    event PriceUpdated(bytes32 indexed code, uint oldPrice, uint newPrice);\r\n    event PromoStarted(bytes32 indexed code, uint percent, uint duration);\r\n    event PromoEnded(bytes32 indexed code);\r\n    event ManagerAuthorized(address indexed manager);\r\n    event ManagerRevoked(address indexed manager);\r\n\r\n    error ProductNotFound(bytes32 code);\r\n    error InsufficientStock(bytes32 code, uint available, uint requested);\r\n    error ProductOutOfStock(bytes32 code);\r\n    error ProductAlreadyExists(bytes32 code);\r\n    error UnauthorizedManager();\r\n\r\n    constructor() {\r\n        admin = msg.sender;\r\n        authorizedManagers[admin] = true;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"Only admin can call this function\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorizedManager() {\r\n        if (!authorizedManagers[msg.sender]) revert UnauthorizedManager();\r\n        _;\r\n    }\r\n\r\n    function authorizeManager(address manager) external onlyAdmin {\r\n        authorizedManagers[manager] = true;\r\n        emit ManagerAuthorized(manager);\r\n    }\r\n\r\n    function revokeManager(address manager) external onlyAdmin {\r\n        authorizedManagers[manager] = false;\r\n        emit ManagerRevoked(manager);\r\n    }\r\n\r\n    function addProduct(\r\n        bytes32 code,\r\n        string memory description,\r\n        uint price,\r\n        uint initialStock\r\n    ) public onlyAdmin {\r\n        for (uint i = 0; i < products.length; i++) {\r\n            if (products[i].code == code) revert ProductAlreadyExists(code);\r\n        }\r\n\r\n        products.push(Product({\r\n            code: code,\r\n            description: description,\r\n            price: price,\r\n            inStock: initialStock > 0,\r\n            stock: initialStock\r\n        }));\r\n\r\n        productIndex[code] = products.length - 1;\r\n        emit ProductAdded(code, description, price);\r\n    }\r\n\r\n    function updatePrice(bytes32 code, uint newPrice) external onlyAdmin {\r\n        uint index = findProductIndex(code);\r\n        uint oldPrice = products[index].price;\r\n        products[index].price = newPrice;\r\n        emit PriceUpdated(code, oldPrice, newPrice);\r\n    }\r\n\r\n    function increaseStock(bytes32 code, uint amount) public onlyAdmin {\r\n        uint index = findProductIndex(code);\r\n        Product storage p = products[index];\r\n        p.stock += amount;\r\n        if (p.stock > 0) p.inStock = true;\r\n        emit StockUpdated(code, p.stock);\r\n    }\r\n\r\n    function decreaseStock(bytes32 code, uint amount) external onlyAuthorizedManager {\r\n        uint index = findProductIndex(code);\r\n        Product storage p = products[index];\r\n        if (p.stock < amount) revert InsufficientStock(code, p.stock, amount);\r\n\r\n        p.stock -= amount;\r\n        if (p.stock == 0) p.inStock = false;\r\n        emit StockUpdated(code, p.stock);\r\n    }\r\n\r\n    function findProductIndex(bytes32 code) internal view returns (uint) {\r\n        uint index = productIndex[code];\r\n        if (index >= products.length || products[index].code != code) {\r\n            for (uint i = 0; i < products.length; i++) {\r\n                if (products[i].code == code) return i;\r\n            }\r\n            revert ProductNotFound(code);\r\n        }\r\n        return index;\r\n    }\r\n\r\n    function getProduct(bytes32 code) public view returns (Product memory) {\r\n        uint index = findProductIndex(code);\r\n        return products[index];\r\n    }\r\n\r\n    function isAvailable(bytes32 code, uint quantity) external view returns (bool) {\r\n        uint index = findProductIndex(code);\r\n        Product memory product = products[index];\r\n        return product.inStock && product.stock >= quantity;\r\n    }\r\n\r\n    function calculateFinalPrice(bytes32 code) public view returns (uint) {\r\n        uint index = findProductIndex(code);\r\n        uint basePrice = products[index].price;\r\n\r\n        if (isPromoActive(code)) {\r\n            Promo memory promo = productPromos[code];\r\n            uint discount = (basePrice * promo.percent) / 100;\r\n            return basePrice - discount;\r\n        }\r\n\r\n        return basePrice;\r\n    }\r\n\r\n    function startProductPromo(bytes32 code, uint ndays, uint percent) external onlyAdmin {\r\n        require(percent <= 100, \"Percent cannot exceed 100\");\r\n        uint index = findProductIndex(code);\r\n        require(index < products.length, \"Product does not exist\");\r\n\r\n        productPromos[code] = Promo({\r\n            start: block.timestamp,\r\n            end: block.timestamp + (ndays * 24 * 60 * 60),\r\n            state: State.Active,\r\n            percent: percent\r\n        });\r\n\r\n        emit PromoStarted(code, percent, ndays);\r\n    }\r\n\r\n    function startPromoBatch(bytes32[] memory codes, uint ndays, uint percent) external onlyAdmin {\r\n        require(percent <= 100, \"Percent cannot exceed 100\");\r\n\r\n        for (uint i = 0; i < codes.length; i++) {\r\n            productPromos[codes[i]] = Promo({\r\n                start: block.timestamp,\r\n                end: block.timestamp + (ndays * 24 * 60 * 60),\r\n                state: State.Active,\r\n                percent: percent\r\n            });\r\n            emit PromoStarted(codes[i], percent, ndays);\r\n        }\r\n    }\r\n\r\n    function endPromo(bytes32 code) external onlyAdmin {\r\n        Promo storage p = productPromos[code];\r\n        p.end = block.timestamp;\r\n        p.state = State.Expired;\r\n        emit PromoEnded(code);\r\n    }\r\n\r\n    function isPromoActive(bytes32 code) public view returns (bool) {\r\n        Promo memory p = productPromos[code];\r\n        return p.state == State.Active &&\r\n            block.timestamp >= p.start &&\r\n            block.timestamp <= p.end;\r\n    }\r\n\r\n    function getProducts(bool filterInStock, bool filterInPromo)\r\n    public\r\n    view\r\n    returns (Product[] memory)\r\n    {\r\n        uint count = 0;\r\n\r\n        for (uint i = 0; i < products.length; i++) {\r\n            if ((!filterInStock || products[i].inStock) &&\r\n                (!filterInPromo || isPromoActive(products[i].code))) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        Product[] memory result = new Product[](count);\r\n        uint j = 0;\r\n        for (uint i = 0; i < products.length; i++) {\r\n            if ((!filterInStock || products[i].inStock) &&\r\n                (!filterInPromo || isPromoActive(products[i].code))) {\r\n                result[j] = products[i];\r\n                j++;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function getProductsWithPrices() external view returns (\r\n        Product[] memory productList\r\n    ) {\r\n        productList = new Product[](products.length);\r\n\r\n        for (uint i = 0; i < products.length; i++) {\r\n            productList[i] = products[i];\r\n            productList[i].price = calculateFinalPrice(products[i].code);\r\n        }\r\n    }\r\n\r\n    function getProductCount() external view returns (uint) {\r\n        return products.length;\r\n    }\r\n}"
      }
    }
  }
}