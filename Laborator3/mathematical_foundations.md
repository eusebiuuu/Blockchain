## Digital Signatures in Blockchain: ECDSA and EdDSA

- Elliptic Curve Digital Signature Algorithm (ECDSA)
- Edwards-curve Digital Signature Algorithm (EdDSA)
- ECDSA in Bitcoin and Ethereum
- SegWit's solution to signature malleability

## 1. Mathematical Foundations of Elliptic Curve Cryptography

### 1.1 Elliptic Curve Equation

An elliptic curve over a finite field $\mathbb{F}_p$ is defined by the Weierstrass equation:

$$y^2 = x^3 + ax + b \pmod{p}$$

where $4a^3 + 27b^2 \neq 0$ (to ensure the curve is non-singular. A singular curve is a curve with a singular point - where all the partial derivatives of the curve's equation are simultaneously equal to zero).

### 1.2 Point Addition

For two points $P = (x_1, y_1)$ and $Q = (x_2, y_2)$ on the curve, their sum $R = P + Q = (x_3, y_3)$ is computed as:

**If $P \neq Q$ (Point Addition):**

$$\lambda = \frac{y_2 - y_1}{x_2 - x_1} \pmod{p}$$

$$x_3 = \lambda^2 - x_1 - x_2 \pmod{p}$$

$$y_3 = \lambda(x_1 - x_3) - y_1 \pmod{p}$$

**If $P = Q$ (Point Doubling):**

$$\lambda = \frac{3x_1^2 + a}{2y_1} \pmod{p}$$

$$x_3 = \lambda^2 - 2x_1 \pmod{p}$$

$$y_3 = \lambda(x_1 - x_3) - y_1 \pmod{p}$$

**If $x_1 = x_2$:** the result of addition is infinity.

### 1.3 Scalar Multiplication

The scalar multiplication $Q = dG$ represents adding the generator point $G$ to itself $d$ times:

$$Q = \underbrace{G + G + \cdots + G}_{d \text{ times}}$$

This operation is computationally efficient in the forward direction but intractable in reverse (the **Elliptic Curve Discrete Logarithm Problem** or ECDLP).


## 2. ECDSA (Elliptic Curve Digital Signature Algorithm)

### 2.1 ECDSA Mathematical Definition

**Domain Parameters:**
- $p$: prime modulus
- $a, b$: curve coefficients
- $G$: generator point (base point)
- $n$: order of $G$ (number of points generated by $G$)
- $h$: cofactor

**Key Generation:**
1. Select a random private key: $d_A \in [1, n-1]$
2. Compute public key: $Q_A = d_A \cdot G$

**Signature Generation:**

To sign a message $m$:

1. Compute message hash: $e = \text{HASH}(m)$
2. Convert hash to integer: $z = e \pmod{n}$
3. Select random nonce: $k \in [1, n-1]$
4. Compute point: $(x_1, y_1) = k \cdot G$
5. Compute signature component: $r = x_1 \pmod{n}$
    - If $r = 0$, return to step 3
6. Compute signature component: $s = k^{-1}(z + rd_A) \pmod{n}$
    - If $s = 0$, return to step 3
7. The signature is the pair: $(r, s)$

#### Observations

- $k$ has an inverse $k^{-1}$ because $n$ is prime, so $(k,n) = 1$.
- $r$ should not be 0 because we need the check the signature against the public key, using the private key $rd_A$.
- $k$ should be used only once. If the same $k$ is used twice for two different signatures an attacker might deduce the private key $d_A$ using the equations:

  $s_1k = z_1 + r_1d_A \pmod{n}$

  $s_1k = z_2 + r_1d_A \pmod{n}$


**Signature Verification:**

To verify signature $(r, s)$ on message $m$ with public key $Q_A$:

1. Verify $r, s \in [1, n-1]$
2. Compute message hash: $e = \text{HASH}(m)$
3. Convert to integer: $z = e \pmod{n}$
4. Compute: $w = s^{-1} \pmod{n}$
5. Compute: $u_1 = zw \pmod{n}$ and $u_2 = rw \pmod{n}$
6. Compute point: $(x_1, y_1) = u_1 \cdot G + u_2 \cdot Q_A$
7. Signature is valid if and only if: $r = x_1 \pmod{n}$

---
### 2.2 ECDSA Verification Correctness Proof

Given signature $(r, s)$ where:
- $r = x_1 \bmod n$ where $(x_1, y_1) = kG$
- $s = k^{-1}(z + rd_A) \bmod n$

Verification computes:
$$w = s^{-1} \bmod n$$
$$u_1 = zw \bmod n, \quad u_2 = rw \bmod n$$
$$(x_1', y_1') = u_1G + u_2Q_A$$

**Proof:**

$$u_1G + u_2Q_A = zwG + rwQ_A$$
$$= zs^{-1}G + rs^{-1}d_AG$$
$$= s^{-1}(z + rd_A)G$$
$$= s^{-1} \cdot sk \cdot G$$
$$= kG = (x_1, y_1)$$

Therefore $x_1' = x_1$, so $r = x_1' \bmod n$ âœ“


### 2.3 Key Properties of ECDSA

1. **Security**: Based on ECDLP hardness
2. **Nonce Critical**: Reusing nonce $k$ leaks private key
3. **Signature Malleability**: $(r, s)$ and $(r, -s \bmod n)$ are both valid (important for Bitcoin)

#%% md
### 2.4 ECDSA Vulnerabilities

**Nonce Reuse Attack:**

If the same nonce $k$ is used for two different messages $m_1$ and $m_2$:

$$s_1 = k^{-1}(z_1 + rd_A) \bmod n$$
$$s_2 = k^{-1}(z_2 + rd_A) \bmod n$$

Then:
$$s_1 - s_2 = k^{-1}(z_1 - z_2) \bmod n$$
$$k = (z_1 - z_2)(s_1 - s_2)^{-1} \bmod n$$

Once $k$ is known:
$$d_A = r^{-1}(ks_1 - z_1) \bmod n$$

**Famous Examples:**
- PlayStation 3 hack (2010): Sony reused nonce, exposing signing key
- Android Bitcoin wallets (2013): Weak RNG led to key extraction

