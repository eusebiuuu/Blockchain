## Solidity basics

### Memory locations

There are three types of memory locations:

• **storage**: is used to permanently store data on the blockchain. State variables are stored in storage and have lifetime limited to the lifetime of the contract. Contract storage acts as a public database, from which values can be read with no fees. However, storing is expensive in terms of gas cost. Storage data is visible to all functions.

• **memory**: is used for temporary data required for local processing within functions and is less expensive in terms of gas cost. For some parameters, for example for string parameters it is mandatory to specify memory location.  

• **calldata**: non-modifiable, non-persistent data; it is used for msg object and it’s the default location for parameters of external functions (functions that can only be called by other contracts).

### Types

Solidity is statically typed, each variable has a type. Variables have default values, depending on their type.

Value types store variable value:

-	**Numeric types**: integers int/uint and fixed-point number fixed/unfixed. Fixed/unfixed are not fully supported.  

-	**Booleans**: bool possible values true/false.

-	**Addresses** address and payable address. Both address and payable address are 20 bytes vales of an Ethereum addresses and may be used to query balances, with member balance. Payable address has additional members: transfer and send. Payable addresses are addresses one can send eth to. To directly interact with contract code, address has members:  call, delegatecall and staticcall.

-	**Fixed size byte arrays**: bytes1, … bytes32. Fixed size byte arrays cost less than string in terms of gas.

-	**Enums** are user defined types that assign names to an integral constants starting from 0.

Reference types store variable location:

-	**mappings**: resembles hash tables. Each possible key exists, and it’s mapped to a default value (all bytes 0). 

    - 	Syntax for mapping declaration: 
mapping(KeyType KeyName? => ValueType ValueName?) 
KeyName and ValueName are optional. KeyType can be any built-in value type, bytes, string, or any contract or enum type. ValueType can be any type.

    -   keccak256 hash is used on key to look up the value mapped to the key.

    -	Mappings can only have storage data location.

-	**struct**: Custom defined types that group a set of variables.

-	**arrays** can have a compile-time fixed size, or a dynamic size. We may append elements in a dynamically sized array calling member push and get the size of the array accessing member length. The index of the first element of an array is 0. Array elements can be of any type, including mapping or struct.

-	**bytes** is used for arbitrary-length raw byte data

-	**string** is used for arbitrary-length string (UTF-8) data. 

### Contract structure and functions

Each contract may include:
-   state variables declarations,
-   struct types, enum types,
-   functions modifiers,
-   functions,
-   events,
-   errors.

State variables cannot be modified by an external account, but their value is accessible for reading. Modifier `public` adds a default getter method.

### Access modifiers

**external**: function can be called only from another contract or using `this`.  May not be specified for state variables.

**internal**: functions or state variables that may be accessed only within the contract and in derived contracts.

**private**: functions or state variables that may be accessed only within the contract.

**public**: functions or state variables that may be accessed by external user and by the contract. For public state variable a public getter is generated by default.

### Function modifiers

A **view** function is one that doesn't modify the state of the blockchain. A view function does not contain:
- Write state variables statements.
- Emit event statements.
- Sending of eth.
- Creation of other contracts etc.

A **pure** function doesn't modify or read state variables. Pure functions usually include mathematical functions or formatting functions.


### Testing

Once you finish defining the contracts, you can also write some tests to make sure it behaves properly and then run them with the following command"

```bash
npx hardhat test ./test/FidelityPoints.ts
```


### Deployment

As we talked in lab 1, our goal is to deploy the smart contracts. Now that we are finally ready (wallet, environment, testnet), we can proceed to deployment.

The first step is to go to [infura](https://developer.metamask.io/) and create an `API KEY` and get the corresponding `RPC_URL`. These are our credentials used to connect to Sepolia. Add the variable `SEPOLIA_RPC_URL` and `SEPOLIA_PRIVATE_KEY` in an `.env` file located in the main folder of the Hardhat project.

`SEPOLIA_RPC_URL`: an endpoint provided by Infura, Alchemy, or QuickNode that lets your Hardhat project talk to the blockchain. It should start with `https://sepolia.infura.io/v3/`

`SEPOLIA_PRIVATE_KEY`: The private key of the Ethereum wallet that will deploy your contracts and sign transactions.

Now, all you have to do is to run:
```bash
npx hardhat ignition deploy ignition/modules/FidelityPoints.ts --network sepolia
```

Now, check `ingnition/deployments` directory and search for the deployed contract on [Sepolia Testnet Explorer](https://sepolia.etherscan.io/). You've just deployed your first contract! The returned hash is the hash of the created account for the smart contract.

To further interact with it, you have several options:

1. Console:

You can open a terminal in your project and run:
```bash
npx hardhat console --network sepolia
```

Then write some JS code to test the contract functions:

```js
const contract = await ethers.getContractAt("YourContractName", "YOUR_DEPLOYED_ADDRESS");
await contract.yourFunctionName();
```

2. Frontend (recommended)

You can build a website using libraries like `Ethers.js` or `Viem`. Your website connects to a wallet (like MetaMask), which the user uses to sign transactions that call your contract's functions.


**Troubleshooting**

In the `scripts` folder from the Hardhat project there are 2 scripts to be used if the deployment fails, to narrow down the problem faster. 

Firstly, you have the `check-sepolia-balance` which returns the balance of the account you make the transaction with. It's important to have some ETH here since the deployment take some gas and it will fail if you don't have it.

Secondly, you also have the `send-zero-tsx` to check if a 0 ETH transaction succeeds or not.


### Remix IDE

Remix IDE is a browser IDE that replaces the need for configuration of a local blockchain (Hardhat) and setting up the deployment. In other words, you can write contracts directly in the IDE, deploy them in a browser blockchain generated by Remix and also test them in a nice interface. Besides this, as in local network, it also generates a good number of accounts with ETH on them to be able to test properly how transactions are managed.

Moreover, once you link the Remix IDE with your Metamask account, you can also deploy on Sepolia testnet directly from the IDE.

---

### Exercises

1. Extend the existing FidelityPoints smart contract with a new function called `spendPoints`. This function will allow registered users to use some of their accumulated points in exchange for future rewards (such as products or special promotions).

2. Add a new state variable called `totalPoints`, which stores the sum of all points currently held by users. Then, create an internal function that updates this variable whenever points are added or spent.

3. Use Remix IDE to compile and deploy FidelityPoints contract, then interact with its functions to verify that registration, earning, spending, and total point tracking work correctly.

4. Test and deploy the contracts as presented above.

5. In Catalog.sol add a uint stock variable to Product and write functions:
- ```increaseStock(bytes32 code, uint amount)```
- ```decreaseStock(bytes32 code, uint amount)```

6. Extend the existing contract in Catalog.sol in order to link a product to a promotion so that only certain products are part of promotions. Hint you can use mappings and functions:
- ```function startProductPromo(bytes32 memory code, uint ndays, uint percent) external```
- ```function startPromoBatch(bytes32[] memory codes, uint ndays, uint percent) external```

7.  Add a function to practice looping and returning filtered results.
- ```function getProducts(bool inStock, bool inPromo) public view returns (Product[] memory)```

8.   Add a pure function at your choice.

